/*
Design patterns:
 - Design patterns are reusable solutions to common software design problems that occur in
 real-world application development.
 - They are not finished code, but rather templates or guidelines that can be adapted to
 fit specific needs in a project. Design patterns help developers solve problems efficiently,
 improve code readability, and make maintenance easier.
# There are three main categories:
1. Creational Patterns: These deal with object creation mechanisms, trying to create objects in a
manner suitable to the situation. Examples include:

  a. Singleton: Ensures a class has only one instance and provides a global access point to it.
  b. Factory Method: Defines an interface for creating objects, but allows subclasses to alter the type of objects that will be created.
  c. Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
  d. Builder: Separates the construction of a complex object from its representation.
  e. Prototype: Creates new objects by copying an existing object, known as the prototype.

2. Structural Patterns: These deal with object composition, creating relationships between objects
to form larger structures. Examples include:

  a. Adapter: Allows incompatible interfaces to work together.
  b. Bridge: Separates abstraction from implementation, allowing them to vary independently.
  c. Composite: Composes objects into tree-like structures to represent part-whole hierarchies.
  d. Decorator: Allows behavior to be added to an individual object dynamically.
  e. Facade: Provides a simplified interface to a complex system of classes, making it easier to use.

3. Behavioral Patterns: These deal with algorithms and the assignment of responsibilities
between objects. Examples include:

  a. Observer: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.
  b. Strategy: Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
  c. Command: Encapsulates a request as an object, thereby allowing for parameterization of clients with different requests.
  d. State: Allows an object to alter its behavior when its internal state changes.
  e. Chain of Responsibility: Passes a request along a chain of handlers, allowing each handler to process the request or pass it along.
  f. Template Method: Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm.
  g. Interpreter: Implements a specialized language, providing a way to evaluate sentences in a language.
  h. Visitor: Defines a new operation to a class without changing the class.
  i. Memento: Captures and restores an object's internal state.
  j. Mediator: Defines simplified communication between classes to prevent a group of classes from referring to each other directly.
  k. Flyweight: Reduces the cost of creating and manipulating a large number of similar objects.
*/
